React? 
    → 복잡한 사용자 인터페이스(ui)를 쉽게 구축하기 위해 페이스북에서 제작한 라이브러리

라이브러리? (도서관 = 모듈들의 집합)

프레임 워크와 라이브러리의 차이점
    
    *프레임워크 
        코드를 작성할 때 필요한 틀을 제공해주는 것 따라서 개발을 할 때 
        제어권이 개발자가 아닌 프레임워크에 존재, 개발할 때 프레임워크가 가지고 있는 규칙에 의해 작성
        안정성이 있음
    ex) spring, djang, nextjs, nuxtJS

    *라이브러리
        같은 로그인 로직이라 하더라도 passportJS, gotrue, 즉 사용자는 특정 정해져있는 코드를 사용하는 것이 아니라,
        필요로 하는 라이브러리를 선택하서 코드에 적용, 불안정성함(갑자기 서비스가 중단될수 있음)
    ex) nodeJS 설치되는 모든 패키지와 reactJS, jquery

------------------------------------------------------------------------------------------------------------------

React의 JS 구동원리 핵심 컨셉

Components (레고)
- 하나의 페이지를 한가지 이상의 기능을 수행하는 UI단위로 분리한것
- 재사용이 용이, 관리 및 유지보수에 효율적 

Virtual DOM
- react가 가지고 있는 가상돔, 돔의 복사본 (돔 = f12눌렀을때 나오는 태그들, document)
- state(상태)를 react에서 구독(감시), 만약 state에 변화가 생긴가면 그 때 
  가상돔과 실제돔에 비교하여 *수정된 부분만 실제돔에 리렌더링(다시 그려준다)*

1. state에 변화가 생긴다면 (개발자가 원하는 순간에 리렌더링 가능)
2. 수정된 부분(컴포넌트)만 실제 돔에 리렌더링 (렌더링 최적화)

!!!!중요
state(상태, 값)
Components(UI 분리)
Virtual DOM(re 랜더링)

------------------------------------------------------------------------------------
CSR, SSR

CSR(Client Side Rendering)
    * 사용자가 웹페이지를 그린다.
    사용자가 웹페이지를 접속했을 때 프론트엔드 서버에 페이지를 렌더링할때 필요한 리소스 전달

    ex) 페이지가 로드 되었을 떄 상품목록을 그려준다
    이 상품 목록은 백엔드 서버로부터 응답 받은 데이터이다

    위 과정을 사용자가 하게되는것 (사용자가 렌더링 부담)

    장점
     - 페이지에 필요한 리소스들을 사전에 미리 불러와 데이터를 캐싱(저장)하고 있다가 url에 맞는 데이터(페이지)를 보여주기 떄문에 
     초기 렌더링 이후에 렌더링 속도가 빠르다. 

    단점
     - 초기렌더링 속도가 ssr보다 느리다.
     - SEO(검색엔진 최적화)에 불리
     - 검색엔진에 노출이 필요한 사이트에 부적합(페이지가 검색엔진이 검색하였을 때 빈화면이 노출) -> 사용자가 접속해야지만 화면이 그려지기 때문에

SSR(Server Side Rendering)
    * 서버에서 웹페이지를 그린다.
    사용자가 웹페이지를 접속 -> 서버에서 페이지를 랜더링 -> 랜더링된 페이지를 사용자에게 전달
    JS가 로드되기도 전에 완성된 페이지를 사용자가 먼저 확인

    장점
     - SEO 유리 => 웹사이트를 검색엔진이 크롤링하여 사용자에게 제공 가능 
     - 빠른 완선본 페이지 로딩 속도
     - 서버에서 랜더링하기 때문에 사용자가 느끼는 부담이 적다
    
    단점
     - 서버의 부담(생산비용 증가)
     - 무거운 페이지라면 오히려 초기 로딩이 CSR보다 오래 걸리 가능성
     - CSR보다 더 많은 생산비용, 추가 러닝 커브


--------------------------------------------------------------------------------------------
SPA, MPA

SPA(Single Page Application)
    - 페이지가 하나인 어플리케이션(.html 파일이 1개)
    - reactJS와 같은 컴포넌트 기반 라이브러리 및 프레임워크는 SPA에 최적화
    - 사용자가 웹 사이트에 접속당시 번들링 된 리소스들을 한번에 전달 

    그리고 이를 캐싱해 뒀다가 url이 달라짐에 따라 html의 내부를 수정하여 사용자에게 보내주는 것
    따라서 통상적으로 리액트의 파일 구조는 index.html 하나로만 구성되어있음


MPA(Multi Page Application)
    - 페이지가 여러개인 어플리케이션(.html 파일이 여러개)
    - 보통을 SSR방식으로 요청마다 해당 페이지에 필요한 리소스를 불러온다.

--------------------------------------------------------------------------------------------

React는 대표적인 CSR, SPA에 최적화 되어있다

-------------------------------------------------------------------------------------------

    패키지 관리 툴

        - 라이브러리들을 관리하고 설치할수 있는 도구
        ex) npm, npx, yarn, yarn berry

        * npm 
            nodeJS에서 기본적으로 내장되어있는 패키지 관리 툴
            ex) npm i(install) 라이브러리명 (--save) -> 설치
                npm rm(remove) 라이브러리명 -> 삭제


                npm i -g 라이브러리명 (노드 환경 전역에서 설치)
                npm i -D 라이브러리명 (개발환경에서만 사용할 라이브러리를 설치)
                ex) 디버깅툴은 개발자만 보여야함 == 사용자가 굳이 볼 필요

        노드js 설치 -> https://nodejs.org/ko/

        설치 확인 
        터미널에 node -v

----------------------------------------------------------------------------------------

    *npx
        npm과 달리 설치하지 않고 라이브러리를 실행 시켜주는 도구
        단, npx를 사용해야하는 경우는 내 프로젝트에 설치하지 않고 일회성으로 무거운 패키지를 사용해야 할 떄
        설치하지 않고 실행하는 패키지 관리 툴
        npx도 마찬가지로 npm에 기본 설치(5.2v 이상)

        ex) npx create-react-app 프로젝트명 : react 프로젝트를 생성하는 명령어

    *yarn
        과거에는 npm보다 속도, 안정성, 보안성 모두 뛰어나서 이목을 끌었다 
        현재는 거의 차이가 없는 생태, 보안성은 제외


    *yarn berry 
        npm과 yarn의 경우는 설치된 라이브러리들은 node_moduels라고 하는 파일에 저장 
        pnp 방식을 도입(zero install)
        알집으로 파일을 관리하고 있기 때문에 프로젝트 자체가 가볍고 빌드가 빨라진다.

        ** 모노레포
         -> 하나의 워크스페이스(폴더)를 통해 여러게의 프로젝트를 담고 관리할 수 있음

         본래 모노레포는 yarn과 turbo 라이브러리를 통해 구축하였으나 
         yarn berry는 보다 모노레포에 최적화 되어있는 패키지 관리 툴

         그러나, 다른 프로젝트를 한 폴더에 둔다는 것은 폴더의 구조나 신경써야하는 부분들이 
         배로 늘어난다는 이야기 따라서 처기에 적용하지 않는 것은 좋지않고 이미 사용자가 
         충분히 확보된 복잡한 프로젝트를 간단하게 만들기 위해 사용 




----------------------------------------------------------------------------------------- 

* React 생성

1. 터미널 명령어를 통해 내가 프로제트를 생성하고자 하는 위치 경로를 맞춤
2. 명령어
    create-react-app (CRA) webpack5(번들링 도구)

    vite esBuild 초보자가 사용하기에 적합하지 않음
    CRA는 react에서 직접만든 명령어 굉장히 편리한 라이브러리들이 이미 설치 및 세팅

    CRA는 react에 필요한 모든 설정파일을 대신 설정 (웹팩과 같은 번들링도구, 바벨과 같은 트랜스파일러)
    단점, 이미 설치된 도구를 커스텀하기 힘들다 
    carco와 같은 CRA 전용 설정 라이브러리를 통해 커스텀 해야한다.

3. npx create-react-app 프로젝트명(ex1) / npx(설치하지 않고 라이브러리를 실행)
    * 폴더 경로 꼭 확인

4.  cd ex1
    npm start -> 로컬환경에서의 웹서버 실행 

    *react실행의 기본 port는 3000번
    따라서 프로젝트  실행 시 기본주소는 http://localhost:300/

  Local:            http://localhost:3000           -> 내 컴퓨터로 실행할 때    
  On Your Network:  http://192.168.200.102:3000     -> 다른사람이 실행할 때 url

-----------------------------------------------------------------------------------

webpack
    모듈 번들러
        모듈 -> 한가지 이상의 기능을 하는 분리된 코드의 집합, 덩어리
        번들러 -> 묶어주는 것

        html,css, js, img
        정리되지않은 리소스들을 확장자명 혹은 특정기준으로 분류하고 묶어주는 역할 

        모듈번들러인 웹팩을 사용하면 필요한 리소스만 찾을수 있기 떄문에 네트워크 연산 비용이 줄어들게 됨

        1. 모듈단위의 개발이 가능
        2. 네트워트 연산 비용 감소
        3. loader라는 기능을 통해 js가 로드할 수 없는 파일도 로드할수 있는 상태로 컴파일(변환)



babel
    트랜스파일러 (번역기)
        ES6(ES2015)이후 - 모던 자바스크립트

        최신문법들을 이해하지 못하는 웹 브라우저 로더들이 해당 언어를 이해할수 있도록 
        저레벨의 문법으로 트랜스파일하여 이해할수 있도록 변환 

    *react에서 babel 중 4가지 모듈 사용
    1. @babel/core  바벨을 구동시키기 위한 핵심 요소
    2. @babel/cli  명령어를 통해 cmd에서 바벨 명령어 사용 가능
    3. @babel/preset-env 바벨의 가장 기본적인 설정들
    4. @babel/preset-react 바벨을 JSX문법도 이해 할수 있도록 해주는 모듈

    JSX (react 문법)

------------------------------------------------------------------------------------

    개발자로서의 가치관 
        협업 가능한 개발자
        변화에 긴밀하게 적응할 수 있는 개발자 
        클린 코드를 작성할 수 있는 개발자
        안되는 것에 대한 두려움을 극복하고자 하는 자세
        어려운 코드를 설명할 수 있는 개발자 
        오픈마인드와 긍정적인 사고를 가진 개발자
        문제를 해결하는 개발자 

        -> 비즈니스를 이해하고 생산성에 기여하는 개발자

        * 생산성 있는 개발자? 
            가치 및 이익을 창출할수 있는 
            요구사항에 맞춰 아키텍쳐를 잘 짤수있는 

------------------------------------------------------------------------------------

리액트 구조

    1. node_modules
        - 현재 프로젝트에 설치된 라이브러리들의 실제 파일 
          용량이 높은편 그래서 git에는 올리지 않습니다.

    2. public 
        - 정적 파일들 보관소 (변하지 않는 파일) ex) index.html , favicon, seo

    3. src
        - 실제 개발이 진행 될 곳

    4. .gitignore
        - git에 올라기지 말아야 할 파일 

    5. package-lock.json
        - maven역할, 라이브러리 설치 시, 라이브러리 설치에 필요한 정확한 정보 

    6. package.json
        - 설치된 라이브러리의 목록과 버전을 관리, 실행 스크립트(명령어)와 프로젝트 설정 

    * npm install (npm i)-> 라이브러리들을 설치 해줌


------------------------------------------------------------------------

    src 구조 

        1. App.css
             - app.js에 참조되어있는 기본 css파일
             - index.js app.js는 react 구조상 index.html을 제외한 최상위 컴포넌트 
               app.css는 모든 컴포넌트에 적용

             - 그러나 react에서 가장 많이 사용하는 것을 일반적인 css가 아닌
               js안에 css를 작성할 수 있는 css-in-js를 활용
               따라서 삭제해도 무방

               (css-in-js에 전역스타일링 기능이 따로 탑재)


        2. App.js
             - routing, 라이브러리들의 provider(설정) = 주소설정 

        3. App.teat.js
             - 테스트 코트의 샘플 

        4. index.css
             - app.css와 동일 
        5. index.js
             - 최상위 컴포넌트의 index.html의 root에 app.js를 전달 (렌더링)
        6. logo.svg
        7. reportWebVitals.js
             - 프론트엔트 성능 체크 (라이트하우스 체크) 
        8. setupTests.js
             - 테스트 라이브러리의 전역 참조 설정 (여기에 임포트하면 모든 테스트코드에 적용됨)
             
        

























































    